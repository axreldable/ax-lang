{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ax-lang","text":"<p>Axreldable programing language.</p>"},{"location":"api/","title":"References","text":""},{"location":"api/#interpreter-class","title":"Interpreter Class","text":""},{"location":"api/#ax_lang.interpreter.ax_lang.AxLang","title":"<code>AxLang</code>","text":"Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>class AxLang:\n    def __init__(self, global_env: Environment):\n        \"\"\"Creates an ax-lang instance with global environment\"\"\"\n        self.global_env = global_env\n        self.transformer = Transformer()\n\n    def _is_variable_name(self, expr):\n        return isinstance(expr, str) and bool(\n            re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", expr)\n        )\n\n    def _is_function_name(self, expr):\n        return isinstance(expr, str) and expr in native_function_names()\n\n    def _eval_block(self, block, env):\n        logger.debug(f\"Evaluating block=`{block}`...\")\n        rez = None\n        for expr in block:\n            rez = self.eval(expr, env)\n        return rez\n\n    def _eval_body(self, body, env):\n        if body[0] == \"begin\":\n            return self._eval_block(body[1:], env)\n        logger.debug(f\"Evaluating body: `{body}`...\")\n        return self.eval(body, env)\n\n    def _call_user_defined_function(self, fn, eval_args):\n        activation_record = {}\n        for i, param in enumerate(fn[\"params\"]):\n            activation_record[param] = eval_args[i]\n        activation_env = Environment(activation_record, fn[\"env\"])\n        return self._eval_body(fn[\"body\"], activation_env)\n\n    def eval(self, expr: Number | str | list, env: Environment = None):\n        logger.debug(f\"Expr: {expr}\")\n        env = self.global_env if env is None else env\n        # Self-evaluating expressions:\n        if isinstance(expr, Number):\n            return expr\n\n        if isinstance(expr, str):\n            if expr[0] == '\"' and expr[-1] == '\"':\n                return expr[1:-1]\n\n        # Variable declaration:\n        if expr[0] == \"var\":\n            _, name, value = expr\n            return env.define(name, self.eval(value, env))\n\n        # Variable update:\n        if expr[0] == \"set\":\n            _, ref, value = expr\n\n            # Assignment to property\n            if ref[0] == \"prop\":\n                _, instance, prop_name = ref\n                instance_env = self.eval(instance, env)\n                return instance_env.define(prop_name, self.eval(value, env))\n\n            return env.assign(ref, self.eval(value, env))\n\n        # Variable access:\n        if self._is_variable_name(expr):\n            return env.lookup(expr)\n\n        # Block: sequence of expressions\n        if expr[0] == \"begin\":\n            block_env = Environment({}, env)\n            return self._eval_block(expr[1:], block_env)\n\n        # if-expression\n        if expr[0] == \"if\":\n            _, condition, consequent, alternate = expr\n            if self.eval(condition, env):\n                return self.eval(consequent, env)\n            return self.eval(alternate, env)\n\n        # while-expression\n        if expr[0] == \"while\":\n            _, condition, body = expr\n            rez = None\n            while self.eval(condition, env):\n                rez = self.eval(body, env)\n            return rez\n\n        # build-in functions\n        if self._is_function_name(expr):\n            return env.lookup(expr)\n\n        # function declaration\n        if expr[0] == \"def\":\n            # JIT-transpile to a variable declaration\n            var_expr = self.transformer.def_to_lambda(expr)\n            return self.eval(var_expr, env)\n\n        # switch-expression (syntactic sugar for if-expression)\n        if expr[0] == \"switch\":\n            if_exp = self.transformer.switch_to_if(expr)\n            return self.eval(if_exp, env)\n\n        # for-loop (syntactic sugar for while-loop)\n        if expr[0] == \"for\":\n            while_exp = self.transformer.for_to_while(expr)\n            return self.eval(while_exp, env)\n\n        # ++ (syntactic sugar for set operation)\n        if expr[0] == \"++\":\n            set_exp = self.transformer.inc_to_set(expr)\n            return self.eval(set_exp, env)\n\n        # ++ (syntactic sugar for set operation)\n        if expr[0] == \"--\":\n            set_exp = self.transformer.dec_to_set(expr)\n            return self.eval(set_exp, env)\n\n        # += (syntactic sugar for set operation)\n        if expr[0] == \"+=\":\n            set_exp = self.transformer.plus_assign_to_set(expr)\n            return self.eval(set_exp, env)\n\n        # -= (syntactic sugar for set operation)\n        if expr[0] == \"-=\":\n            set_exp = self.transformer.minus_assign_to_set(expr)\n            return self.eval(set_exp, env)\n\n        # lambda declaration\n        if expr[0] == \"lambda\":\n            _, params, body = expr\n            rez_lambda = {\n                \"params\": params,\n                \"body\": body,\n                \"env\": env,\n            }\n            logger.debug(f\"Evaluated lambda: `{rez_lambda}`...\")\n            return rez_lambda\n\n        # Class declaration (class name parent body)\n        if expr[0] == \"class\":\n            _, name, parent, body = expr\n            parent_env = self.eval(parent, env) or env\n            class_env = Environment({}, parent_env)\n            # body is evaluated in the class environment\n            self._eval_body(body, class_env)\n            # Class is accessible by name\n            return env.define(name, class_env)\n\n        # Super expressions (super &lt;class_name&gt;)\n        if expr[0] == \"super\":\n            _, class_name = expr\n            return self.eval(class_name, env).parent\n\n        # Class instantiation (new class arguments)\n        if expr[0] == \"new\":\n            class_env = self.eval(expr[1], env)\n            # An instance of class is an environment\n            instance_env = Environment({}, class_env)\n            eval_args = [self.eval(arg, env) for arg in expr[2:]]\n            self._call_user_defined_function(\n                class_env.lookup(\"constructor\"), [instance_env, *eval_args]\n            )\n            return instance_env\n\n        # property access: (prop &lt;instance&gt; &lt;name&gt;)\n        if expr[0] == \"prop\":\n            _, instance, name = expr\n            instance_env = self.eval(instance, env)\n            return instance_env.lookup(name)\n\n        # module declaration: (module &lt;name&gt; &lt;body&gt;)\n        if expr[0] == \"module\":\n            _, name, body = expr\n            module_env = Environment({}, env)\n            self._eval_body(body, module_env)\n            return env.define(name, module_env)\n\n        # module import: (import &lt;name&gt;)\n        if expr[0] == \"import\":\n            _, name = expr\n\n            module_src = None\n            local_dirs = __file__.split(\"/\")\n            local_dirs = local_dirs[: (len(local_dirs) - 1)]\n            local_path = \"/\".join(local_dirs)\n            with open(f\"{local_path}/modules/{name}.ax\") as f:\n                module_src = f.read()\n\n            body = get_lisp_representation(f\"(begin {module_src})\")\n            module_expr = [\"module\", name, body]\n            return self.eval(module_expr, env)\n\n        # Function calls:\n        if isinstance(expr, list):\n            fn = self.eval(expr[0], env)\n            logger.debug(f\"Processing fn: `{fn}`...\")\n            eval_args = [self.eval(arg, env) for arg in expr[1:]]\n\n            # 1. Native functions\n            if isinstance(fn, types.FunctionType):\n                logger.debug(f\"Applying fn: `{fn.__name__}` to args: `{eval_args}`...\")\n                return fn(*eval_args)\n\n            # 2. User-defined functions\n            # it's type dict here\n            if isinstance(fn, dict):\n                logger.debug(f\"Processing User-defined function `{fn}`...\")\n                return self._call_user_defined_function(fn, eval_args)\n\n            raise NotImplementedError(fn)\n        raise NotImplementedError(expr)\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.AxLang.__init__","title":"<code>__init__(global_env)</code>","text":"<p>Creates an ax-lang instance with global environment</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>def __init__(self, global_env: Environment):\n    \"\"\"Creates an ax-lang instance with global environment\"\"\"\n    self.global_env = global_env\n    self.transformer = Transformer()\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.Environment","title":"<code>Environment</code>","text":"Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>class Environment:\n    def __init__(self, record: dict, parent: \"Environment\" = None):\n        self.record = record\n        self.parent = parent\n\n    def define(self, name, value):\n        \"\"\"Creates a variable with given name and value in the current Environment\"\"\"\n        logger.debug(f\"Defining name=`{name}` with value=`{value}` in the current env.\")\n        self.record[name] = value\n        return value\n\n    def assign(self, name, value):\n        \"\"\"Updates an existing variable.\"\"\"\n        name = str(name)  # in case need to assign ['prop', 'this', 'x']\n        var_env = self.resolve(name)\n        var_env.record[name] = value\n        return value\n\n    def lookup(self, name):\n        \"\"\"Returns the value of the variable\n        or throws if it's not defined.\n        \"\"\"\n        var_env = self.resolve(name)\n        return var_env.record[name]\n\n    def resolve(self, name) -&gt; \"Environment\":\n        \"\"\"Returns the specific env in which the variable is defined.\n        Throws if the variable is not defined.\n        \"\"\"\n        name = str(name)  # in case need to resolve ['prop', 'this', 'x']\n        if name in self.record:\n            return self\n        if not self.parent:\n            raise ValueError(f\"Variable `{name}` is not defined!\")\n        return self.parent.resolve(name)\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.Environment.assign","title":"<code>assign(name, value)</code>","text":"<p>Updates an existing variable.</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>def assign(self, name, value):\n    \"\"\"Updates an existing variable.\"\"\"\n    name = str(name)  # in case need to assign ['prop', 'this', 'x']\n    var_env = self.resolve(name)\n    var_env.record[name] = value\n    return value\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.Environment.define","title":"<code>define(name, value)</code>","text":"<p>Creates a variable with given name and value in the current Environment</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>def define(self, name, value):\n    \"\"\"Creates a variable with given name and value in the current Environment\"\"\"\n    logger.debug(f\"Defining name=`{name}` with value=`{value}` in the current env.\")\n    self.record[name] = value\n    return value\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.Environment.lookup","title":"<code>lookup(name)</code>","text":"<p>Returns the value of the variable or throws if it's not defined.</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>def lookup(self, name):\n    \"\"\"Returns the value of the variable\n    or throws if it's not defined.\n    \"\"\"\n    var_env = self.resolve(name)\n    return var_env.record[name]\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.Environment.resolve","title":"<code>resolve(name)</code>","text":"<p>Returns the specific env in which the variable is defined. Throws if the variable is not defined.</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>def resolve(self, name) -&gt; \"Environment\":\n    \"\"\"Returns the specific env in which the variable is defined.\n    Throws if the variable is not defined.\n    \"\"\"\n    name = str(name)  # in case need to resolve ['prop', 'this', 'x']\n    if name in self.record:\n        return self\n    if not self.parent:\n        raise ValueError(f\"Variable `{name}` is not defined!\")\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.Transformer","title":"<code>Transformer</code>","text":"Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>class Transformer:\n    def def_to_lambda(self, def_expr):\n        \"\"\"Translates `def`-expression (function declaration) into a variable declaration with a lambda expression.\"\"\"\n        _, name, params, body = def_expr\n        return [\"var\", name, [\"lambda\", params, body]]\n\n    def switch_to_if(self, switch_expr):\n        \"\"\"\n        Example:\n            Transforming switch expr=`['switch', [['==', 'x', 10], 100], [['&gt;', 'x', 10], 200], ['else', 300]]`...\n            Result if expr=`['if', ['==', 'x', 10], 100, ['if', ['&gt;', 'x', 10], 200, 300]]`.\n        \"\"\"\n        # ['switch', [['=', 'x', 10], 100], [['&gt;', 'x', 10], 200], ['else', 300]]\n        # ['if', ['==', 'x', 10], 100, ['if', ['&gt;', 'x', 10], 200, 300]]\n        logger.debug(f\"Transforming switch expr=`{switch_expr}`...\")\n        _, *cases = switch_expr\n        if_expr = [\"if\", None, None, None]\n        curr_if = if_expr\n        for i in range(len(cases) - 1):\n            curr_cond, curr_block = cases[i]\n            curr_if[1] = curr_cond\n            curr_if[2] = curr_block\n\n            next_cond, next_block = cases[i + 1]\n            curr_if[3] = next_block if next_cond == \"else\" else [\"if\", None, None, None]\n\n            curr_if = curr_if[3]\n        logger.debug(f\"Result if expr=`{if_expr}`.\")\n        return if_expr\n\n    def for_to_while(self, for_expr):\n        \"\"\"\n        Transforming `for` expr=`['for', ['var', 'counter', 0], ['&lt;', 'counter', 10],\n            ['set', 'counter', ['+', 'counter', 1]], ['set', 'rez', ['+', 'rez', 2]]]`...\n        Result `while` expr=`['begin', ['var', 'counter', 0], ['while', ['&lt;', 'counter', 10],\n            ['begin', ['set', 'rez', ['+', 'rez', 2]], ['set', 'counter', ['+', 'counter', 1]]]]]`.\n        \"\"\"\n        logger.debug(f\"Transforming `for` expr=`{for_expr}`...\")\n        _, init, condition, modifier, body = for_expr\n        while_expr = [\n            \"begin\",\n            init,\n            [\"while\", condition, [\"begin\", body, modifier]],\n        ]\n        logger.debug(f\"Result `while` expr=`{while_expr}`.\")\n        return while_expr\n\n    def inc_to_set(self, expr):\n        _, var = expr\n        set_expr = [\"set\", var, [\"+\", var, 1]]\n        return set_expr\n\n    def dec_to_set(self, expr):\n        _, var = expr\n        set_expr = [\"set\", var, [\"-\", var, 1]]\n        return set_expr\n\n    def plus_assign_to_set(self, expr):\n        _, var, value = expr\n        set_expr = [\"set\", var, [\"+\", var, value]]\n        return set_expr\n\n    def minus_assign_to_set(self, expr):\n        _, var, value = expr\n        set_expr = [\"set\", var, [\"-\", var, value]]\n        return set_expr\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.Transformer.def_to_lambda","title":"<code>def_to_lambda(def_expr)</code>","text":"<p>Translates <code>def</code>-expression (function declaration) into a variable declaration with a lambda expression.</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>def def_to_lambda(self, def_expr):\n    \"\"\"Translates `def`-expression (function declaration) into a variable declaration with a lambda expression.\"\"\"\n    _, name, params, body = def_expr\n    return [\"var\", name, [\"lambda\", params, body]]\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.Transformer.for_to_while","title":"<code>for_to_while(for_expr)</code>","text":"<p>Transforming <code>for</code> expr=<code>['for', ['var', 'counter', 0], ['&lt;', 'counter', 10],     ['set', 'counter', ['+', 'counter', 1]], ['set', 'rez', ['+', 'rez', 2]]]</code>... Result <code>while</code> expr=<code>['begin', ['var', 'counter', 0], ['while', ['&lt;', 'counter', 10],     ['begin', ['set', 'rez', ['+', 'rez', 2]], ['set', 'counter', ['+', 'counter', 1]]]]]</code>.</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>def for_to_while(self, for_expr):\n    \"\"\"\n    Transforming `for` expr=`['for', ['var', 'counter', 0], ['&lt;', 'counter', 10],\n        ['set', 'counter', ['+', 'counter', 1]], ['set', 'rez', ['+', 'rez', 2]]]`...\n    Result `while` expr=`['begin', ['var', 'counter', 0], ['while', ['&lt;', 'counter', 10],\n        ['begin', ['set', 'rez', ['+', 'rez', 2]], ['set', 'counter', ['+', 'counter', 1]]]]]`.\n    \"\"\"\n    logger.debug(f\"Transforming `for` expr=`{for_expr}`...\")\n    _, init, condition, modifier, body = for_expr\n    while_expr = [\n        \"begin\",\n        init,\n        [\"while\", condition, [\"begin\", body, modifier]],\n    ]\n    logger.debug(f\"Result `while` expr=`{while_expr}`.\")\n    return while_expr\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.Transformer.switch_to_if","title":"<code>switch_to_if(switch_expr)</code>","text":"Example <p>Transforming switch expr=<code>['switch', [['==', 'x', 10], 100], [['&gt;', 'x', 10], 200], ['else', 300]]</code>... Result if expr=<code>['if', ['==', 'x', 10], 100, ['if', ['&gt;', 'x', 10], 200, 300]]</code>.</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>def switch_to_if(self, switch_expr):\n    \"\"\"\n    Example:\n        Transforming switch expr=`['switch', [['==', 'x', 10], 100], [['&gt;', 'x', 10], 200], ['else', 300]]`...\n        Result if expr=`['if', ['==', 'x', 10], 100, ['if', ['&gt;', 'x', 10], 200, 300]]`.\n    \"\"\"\n    # ['switch', [['=', 'x', 10], 100], [['&gt;', 'x', 10], 200], ['else', 300]]\n    # ['if', ['==', 'x', 10], 100, ['if', ['&gt;', 'x', 10], 200, 300]]\n    logger.debug(f\"Transforming switch expr=`{switch_expr}`...\")\n    _, *cases = switch_expr\n    if_expr = [\"if\", None, None, None]\n    curr_if = if_expr\n    for i in range(len(cases) - 1):\n        curr_cond, curr_block = cases[i]\n        curr_if[1] = curr_cond\n        curr_if[2] = curr_block\n\n        next_cond, next_block = cases[i + 1]\n        curr_if[3] = next_block if next_cond == \"else\" else [\"if\", None, None, None]\n\n        curr_if = curr_if[3]\n    logger.debug(f\"Result if expr=`{if_expr}`.\")\n    return if_expr\n</code></pre>"}]}