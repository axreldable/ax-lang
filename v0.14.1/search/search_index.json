{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ax-lang","text":"<p>Axreldable programming language.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Language Specification - Complete syntax and semantics reference</li> <li>API Documentation - API reference for developers</li> </ul>"},{"location":"api/","title":"References","text":""},{"location":"api/#interpreter-class","title":"Interpreter Class","text":""},{"location":"api/#ax_lang.interpreter.ax_lang.AxLang","title":"<code>AxLang</code>","text":"<p>Tree-walking interpreter for the ax-lang programming language.</p> <p>Evaluates Abstract Syntax Trees (AST) produced by the parser and executes ax-lang programs using environment-based variable scoping, first-class functions, and object-oriented programming features.</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>class AxLang:\n    \"\"\"Tree-walking interpreter for the ax-lang programming language.\n\n    Evaluates Abstract Syntax Trees (AST) produced by the parser and executes\n    ax-lang programs using environment-based variable scoping, first-class functions,\n    and object-oriented programming features.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Creates an ax-lang instance with global environment.\"\"\"\n        self.global_env = GlobalEnvironment\n        self.transformer = Transformer()\n\n    def _is_variable_name(self, expr):\n        return isinstance(expr, str) and bool(\n            re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", expr)\n        )\n\n    def _is_function_name(self, expr):\n        # fmt: off\n        native_function_names = {\"+\", \"-\", \"*\", \"/\", \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\", \"==\", \"print\"}\n        # fmt: on\n        return isinstance(expr, str) and expr in native_function_names\n\n    def _eval_block(self, block, env):\n        logger.debug(f\"Evaluating block=`{block}`...\")\n        rez = None\n        for expr in block:\n            rez = self.eval(expr, env)\n        return rez\n\n    def _eval_body(self, body, env):\n        if body[0] == \"begin\":\n            return self._eval_block(body[1:], env)\n        logger.debug(f\"Evaluating body: `{body}`...\")\n        return self.eval(body, env)\n\n    def _call_user_defined_function(self, fn, eval_args):\n        activation_record = {}\n        for i, param in enumerate(fn[\"params\"]):\n            activation_record[param] = eval_args[i]\n        activation_env = Environment(activation_record, fn[\"env\"])\n        return self._eval_body(fn[\"body\"], activation_env)\n\n    def eval(self, expr: Number | str | list, env: Environment = None):\n        \"\"\"Evaluates an expression in the given environment.\n\n        Args:\n            expr: AST node (number, string, or list) to evaluate\n            env: Environment for evaluation (defaults to global)\n\n        Returns:\n            Result of evaluation - can be a number, string, dict (for functions/classes),\n            or Environment (for class instances)\n\n        Raises:\n            ValueError: If a variable is not defined\n            NotImplementedError: If an expression type is not supported\n        \"\"\"\n        logger.debug(f\"Expr: {expr}\")\n        env = self.global_env if env is None else env\n        # Self-evaluating expressions:\n        if isinstance(expr, Number):\n            return expr\n\n        if isinstance(expr, str):\n            if expr[0] == '\"' and expr[-1] == '\"':\n                return expr[1:-1]\n\n        # Variable declaration:\n        if expr[0] == \"var\":\n            _, name, value = expr\n            return env.define(name, self.eval(value, env))\n\n        # Variable update:\n        if expr[0] == \"set\":\n            _, ref, value = expr\n\n            # Assignment to property\n            if ref[0] == \"prop\":\n                _, instance, prop_name = ref\n                instance_env = self.eval(instance, env)\n                return instance_env.define(prop_name, self.eval(value, env))\n\n            return env.assign(ref, self.eval(value, env))\n\n        # Variable access:\n        if self._is_variable_name(expr):\n            return env.lookup(expr)\n\n        # Block: sequence of expressions\n        if expr[0] == \"begin\":\n            block_env = Environment({}, env)\n            return self._eval_block(expr[1:], block_env)\n\n        # if-expression\n        if expr[0] == \"if\":\n            _, condition, consequent, alternate = expr\n            if self.eval(condition, env):\n                return self.eval(consequent, env)\n            return self.eval(alternate, env)\n\n        # while-expression\n        if expr[0] == \"while\":\n            _, condition, body = expr\n            rez = None\n            while self.eval(condition, env):\n                rez = self.eval(body, env)\n            return rez\n\n        # build-in functions\n        if self._is_function_name(expr):\n            return env.lookup(expr)\n\n        # function declaration\n        if expr[0] == \"def\":\n            # JIT-transpile to a variable declaration\n            var_expr = self.transformer.def_to_lambda(expr)\n            return self.eval(var_expr, env)\n\n        # switch-expression (syntactic sugar for if-expression)\n        if expr[0] == \"switch\":\n            if_exp = self.transformer.switch_to_if(expr)\n            return self.eval(if_exp, env)\n\n        # for-loop (syntactic sugar for while-loop)\n        if expr[0] == \"for\":\n            while_exp = self.transformer.for_to_while(expr)\n            return self.eval(while_exp, env)\n\n        # ++ (syntactic sugar for set operation)\n        if expr[0] == \"++\":\n            set_exp = self.transformer.inc_to_set(expr)\n            return self.eval(set_exp, env)\n\n        # ++ (syntactic sugar for set operation)\n        if expr[0] == \"--\":\n            set_exp = self.transformer.dec_to_set(expr)\n            return self.eval(set_exp, env)\n\n        # += (syntactic sugar for set operation)\n        if expr[0] == \"+=\":\n            set_exp = self.transformer.plus_assign_to_set(expr)\n            return self.eval(set_exp, env)\n\n        # -= (syntactic sugar for set operation)\n        if expr[0] == \"-=\":\n            set_exp = self.transformer.minus_assign_to_set(expr)\n            return self.eval(set_exp, env)\n\n        # lambda declaration\n        if expr[0] == \"lambda\":\n            _, params, body = expr\n            rez_lambda = {\n                \"params\": params,\n                \"body\": body,\n                \"env\": env,\n            }\n            logger.debug(f\"Evaluated lambda: `{rez_lambda}`...\")\n            return rez_lambda\n\n        # Class declaration (class name parent body)\n        if expr[0] == \"class\":\n            _, name, parent, body = expr\n            parent_env = self.eval(parent, env) or env\n            class_env = Environment({}, parent_env)\n            # body is evaluated in the class environment\n            self._eval_body(body, class_env)\n            # Class is accessible by name\n            return env.define(name, class_env)\n\n        # Super expressions (super &lt;class_name&gt;)\n        if expr[0] == \"super\":\n            _, class_name = expr\n            return self.eval(class_name, env).parent\n\n        # Class instantiation (new class arguments)\n        if expr[0] == \"new\":\n            class_env = self.eval(expr[1], env)\n            # An instance of class is an environment\n            instance_env = Environment({}, class_env)\n            eval_args = [self.eval(arg, env) for arg in expr[2:]]\n            self._call_user_defined_function(\n                class_env.lookup(\"constructor\"), [instance_env, *eval_args]\n            )\n            return instance_env\n\n        # property access: (prop &lt;instance&gt; &lt;name&gt;)\n        if expr[0] == \"prop\":\n            _, instance, name = expr\n            instance_env = self.eval(instance, env)\n            return instance_env.lookup(name)\n\n        # module declaration: (module &lt;name&gt; &lt;body&gt;)\n        if expr[0] == \"module\":\n            _, name, body = expr\n            module_env = Environment({}, env)\n            self._eval_body(body, module_env)\n            return env.define(name, module_env)\n\n        # module import: (import &lt;name&gt;)\n        if expr[0] == \"import\":\n            _, name = expr\n\n            module_src = None\n            local_dirs = __file__.split(\"/\")\n            local_dirs = local_dirs[: (len(local_dirs) - 1)]\n            local_path = \"/\".join(local_dirs)\n            with open(f\"{local_path}/modules/{name}.ax\") as f:\n                module_src = f.read()\n\n            body = get_ast(f\"(begin {module_src})\")\n            module_expr = [\"module\", name, body]\n            return self.eval(module_expr, env)\n\n        # Function calls:\n        if isinstance(expr, list):\n            fn = self.eval(expr[0], env)\n            logger.debug(f\"Processing fn: `{fn}`...\")\n            eval_args = [self.eval(arg, env) for arg in expr[1:]]\n\n            # 1. Native functions\n            if isinstance(fn, types.FunctionType):\n                logger.debug(f\"Applying fn: `{fn.__name__}` to args: `{eval_args}`...\")\n                return fn(*eval_args)\n\n            # 2. User-defined functions\n            # it's type dict here\n            if isinstance(fn, dict):\n                logger.debug(f\"Processing User-defined function `{fn}`...\")\n                return self._call_user_defined_function(fn, eval_args)\n\n            raise NotImplementedError(fn)\n        raise NotImplementedError(expr)\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.AxLang.__init__","title":"<code>__init__()</code>","text":"<p>Creates an ax-lang instance with global environment.</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>def __init__(self):\n    \"\"\"Creates an ax-lang instance with global environment.\"\"\"\n    self.global_env = GlobalEnvironment\n    self.transformer = Transformer()\n</code></pre>"},{"location":"api/#ax_lang.interpreter.ax_lang.AxLang.eval","title":"<code>eval(expr, env=None)</code>","text":"<p>Evaluates an expression in the given environment.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Number | str | list</code> <p>AST node (number, string, or list) to evaluate</p> required <code>env</code> <code>Environment</code> <p>Environment for evaluation (defaults to global)</p> <code>None</code> <p>Returns:</p> Type Description <p>Result of evaluation - can be a number, string, dict (for functions/classes),</p> <p>or Environment (for class instances)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a variable is not defined</p> <code>NotImplementedError</code> <p>If an expression type is not supported</p> Source code in <code>ax_lang/interpreter/ax_lang.py</code> <pre><code>def eval(self, expr: Number | str | list, env: Environment = None):\n    \"\"\"Evaluates an expression in the given environment.\n\n    Args:\n        expr: AST node (number, string, or list) to evaluate\n        env: Environment for evaluation (defaults to global)\n\n    Returns:\n        Result of evaluation - can be a number, string, dict (for functions/classes),\n        or Environment (for class instances)\n\n    Raises:\n        ValueError: If a variable is not defined\n        NotImplementedError: If an expression type is not supported\n    \"\"\"\n    logger.debug(f\"Expr: {expr}\")\n    env = self.global_env if env is None else env\n    # Self-evaluating expressions:\n    if isinstance(expr, Number):\n        return expr\n\n    if isinstance(expr, str):\n        if expr[0] == '\"' and expr[-1] == '\"':\n            return expr[1:-1]\n\n    # Variable declaration:\n    if expr[0] == \"var\":\n        _, name, value = expr\n        return env.define(name, self.eval(value, env))\n\n    # Variable update:\n    if expr[0] == \"set\":\n        _, ref, value = expr\n\n        # Assignment to property\n        if ref[0] == \"prop\":\n            _, instance, prop_name = ref\n            instance_env = self.eval(instance, env)\n            return instance_env.define(prop_name, self.eval(value, env))\n\n        return env.assign(ref, self.eval(value, env))\n\n    # Variable access:\n    if self._is_variable_name(expr):\n        return env.lookup(expr)\n\n    # Block: sequence of expressions\n    if expr[0] == \"begin\":\n        block_env = Environment({}, env)\n        return self._eval_block(expr[1:], block_env)\n\n    # if-expression\n    if expr[0] == \"if\":\n        _, condition, consequent, alternate = expr\n        if self.eval(condition, env):\n            return self.eval(consequent, env)\n        return self.eval(alternate, env)\n\n    # while-expression\n    if expr[0] == \"while\":\n        _, condition, body = expr\n        rez = None\n        while self.eval(condition, env):\n            rez = self.eval(body, env)\n        return rez\n\n    # build-in functions\n    if self._is_function_name(expr):\n        return env.lookup(expr)\n\n    # function declaration\n    if expr[0] == \"def\":\n        # JIT-transpile to a variable declaration\n        var_expr = self.transformer.def_to_lambda(expr)\n        return self.eval(var_expr, env)\n\n    # switch-expression (syntactic sugar for if-expression)\n    if expr[0] == \"switch\":\n        if_exp = self.transformer.switch_to_if(expr)\n        return self.eval(if_exp, env)\n\n    # for-loop (syntactic sugar for while-loop)\n    if expr[0] == \"for\":\n        while_exp = self.transformer.for_to_while(expr)\n        return self.eval(while_exp, env)\n\n    # ++ (syntactic sugar for set operation)\n    if expr[0] == \"++\":\n        set_exp = self.transformer.inc_to_set(expr)\n        return self.eval(set_exp, env)\n\n    # ++ (syntactic sugar for set operation)\n    if expr[0] == \"--\":\n        set_exp = self.transformer.dec_to_set(expr)\n        return self.eval(set_exp, env)\n\n    # += (syntactic sugar for set operation)\n    if expr[0] == \"+=\":\n        set_exp = self.transformer.plus_assign_to_set(expr)\n        return self.eval(set_exp, env)\n\n    # -= (syntactic sugar for set operation)\n    if expr[0] == \"-=\":\n        set_exp = self.transformer.minus_assign_to_set(expr)\n        return self.eval(set_exp, env)\n\n    # lambda declaration\n    if expr[0] == \"lambda\":\n        _, params, body = expr\n        rez_lambda = {\n            \"params\": params,\n            \"body\": body,\n            \"env\": env,\n        }\n        logger.debug(f\"Evaluated lambda: `{rez_lambda}`...\")\n        return rez_lambda\n\n    # Class declaration (class name parent body)\n    if expr[0] == \"class\":\n        _, name, parent, body = expr\n        parent_env = self.eval(parent, env) or env\n        class_env = Environment({}, parent_env)\n        # body is evaluated in the class environment\n        self._eval_body(body, class_env)\n        # Class is accessible by name\n        return env.define(name, class_env)\n\n    # Super expressions (super &lt;class_name&gt;)\n    if expr[0] == \"super\":\n        _, class_name = expr\n        return self.eval(class_name, env).parent\n\n    # Class instantiation (new class arguments)\n    if expr[0] == \"new\":\n        class_env = self.eval(expr[1], env)\n        # An instance of class is an environment\n        instance_env = Environment({}, class_env)\n        eval_args = [self.eval(arg, env) for arg in expr[2:]]\n        self._call_user_defined_function(\n            class_env.lookup(\"constructor\"), [instance_env, *eval_args]\n        )\n        return instance_env\n\n    # property access: (prop &lt;instance&gt; &lt;name&gt;)\n    if expr[0] == \"prop\":\n        _, instance, name = expr\n        instance_env = self.eval(instance, env)\n        return instance_env.lookup(name)\n\n    # module declaration: (module &lt;name&gt; &lt;body&gt;)\n    if expr[0] == \"module\":\n        _, name, body = expr\n        module_env = Environment({}, env)\n        self._eval_body(body, module_env)\n        return env.define(name, module_env)\n\n    # module import: (import &lt;name&gt;)\n    if expr[0] == \"import\":\n        _, name = expr\n\n        module_src = None\n        local_dirs = __file__.split(\"/\")\n        local_dirs = local_dirs[: (len(local_dirs) - 1)]\n        local_path = \"/\".join(local_dirs)\n        with open(f\"{local_path}/modules/{name}.ax\") as f:\n            module_src = f.read()\n\n        body = get_ast(f\"(begin {module_src})\")\n        module_expr = [\"module\", name, body]\n        return self.eval(module_expr, env)\n\n    # Function calls:\n    if isinstance(expr, list):\n        fn = self.eval(expr[0], env)\n        logger.debug(f\"Processing fn: `{fn}`...\")\n        eval_args = [self.eval(arg, env) for arg in expr[1:]]\n\n        # 1. Native functions\n        if isinstance(fn, types.FunctionType):\n            logger.debug(f\"Applying fn: `{fn.__name__}` to args: `{eval_args}`...\")\n            return fn(*eval_args)\n\n        # 2. User-defined functions\n        # it's type dict here\n        if isinstance(fn, dict):\n            logger.debug(f\"Processing User-defined function `{fn}`...\")\n            return self._call_user_defined_function(fn, eval_args)\n\n        raise NotImplementedError(fn)\n    raise NotImplementedError(expr)\n</code></pre>"},{"location":"specification/","title":"AxLang Language Specification","text":"<p>This document provides a specification of the AxLang programming language syntax and semantics.</p>"},{"location":"specification/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Expression Evaluation</li> <li>Self-Evaluating Expressions</li> <li>Numbers</li> <li>Strings</li> <li>Binary Operations</li> <li>Variable Declaration</li> <li>Assignment Expressions</li> <li>Variable Access</li> <li>Block Expressions</li> <li>Branching</li> <li>If Expressions</li> <li>Switch Expressions</li> <li>Loops</li> <li>While Loops</li> <li>For Loops</li> <li>Functions<ul> <li>Lambda Expressions</li> <li>Function Declarations</li> <li>Function Calls</li> </ul> </li> <li>Classes</li> <li>Modules</li> </ol>"},{"location":"specification/#1-expression-evaluation","title":"1. Expression Evaluation","text":"<p>AxLang is based on the paradigm, where programs are composed of s-expressions that evaluate to values.</p>"},{"location":"specification/#s-expressions","title":"S-Expressions","text":"<p>AxLang uses S-expressions (Symbolic expressions) as its fundamental syntax, the same notation used in Lisp family programming languages. An S-expression is either:</p> <ol> <li>An atom - a primitive value like a number, string, or symbol</li> <li>A list - zero or more S-expressions enclosed in parentheses</li> </ol> <p>Syntax: <pre><code>&lt;s-expression&gt; ::= &lt;atom&gt; | (&lt;s-expression&gt;*)\n</code></pre></p> <p>Examples:</p> <p>Atoms: <pre><code>42          ; number\n\"hello\"     ; string\nfoo         ; symbol\n</code></pre></p> <p>Lists (prefix notation): <pre><code>(+ 1 2)                    ; function call\n(var x 10)                 ; variable declaration\n(if (&gt; x 0) \"positive\" \"non-positive\")  ; nested expressions\n</code></pre></p> <p>Key Properties:</p> <ul> <li>Prefix notation: The operator or function name comes first, followed by arguments</li> <li>Instead of <code>1 + 2</code>, we write <code>(+ 1 2)</code></li> <li> <p>Instead of <code>x &gt; 0</code>, we write <code>(&gt; x 0)</code></p> </li> <li> <p>Uniform structure: Code and data share the same representation</p> </li> <li>Functions, operators, and special forms all use the same syntax</li> <li> <p>This enables powerful metaprogramming capabilities</p> </li> <li> <p>Explicit grouping: Parentheses eliminate ambiguity about evaluation order</p> </li> <li><code>(+ (* 2 3) 4)</code> is unambiguous (multiply first, then add)</li> <li>No need for operator precedence rules</li> </ul> <p>Evaluation:</p> <p>S-expressions are evaluated recursively: 1. Atoms evaluate to themselves (numbers, strings) or their bound values (symbols) 2. Lists are evaluated as function calls or special forms:    - First element determines the operation    - Remaining elements are the arguments    - Arguments are evaluated before being passed (except in special forms like <code>if</code>, <code>var</code>, etc.)</p>"},{"location":"specification/#2-self-evaluating-expressions","title":"2. Self-Evaluating Expressions","text":"<p>Self-evaluating expressions are literals that evaluate to themselves.</p>"},{"location":"specification/#21-numbers","title":"2.1. Numbers","text":"<p>Expression: <pre><code>^[-+]?\\d+(\\.\\d+)?$\n</code></pre></p> <p>Examples: <pre><code>100\n-5.7\n</code></pre></p> <p>Numbers are self-evaluating. When the interpreter encounters a numeric literal, it directly returns the number value.</p>"},{"location":"specification/#22-strings","title":"2.2. Strings","text":"<p>Expression: <pre><code>\"&lt;chars&gt;\"\n</code></pre></p> <p>Examples: <pre><code>\"hello\"\n\"world\"\n</code></pre></p> <p>String literals enclosed in double quotes are self-evaluating.</p>"},{"location":"specification/#3-binary-operations","title":"3. Binary Operations","text":"<p>AxLang supports three categories of binary operations:</p> <p>Math Operations: <pre><code>(+ 5 10)\n(* x 15)\n(- (/ foo 5) 42)\n</code></pre></p> <p>Comparison Operations: <pre><code>(&lt; 5 10)\n(&gt;= x 15)\n(!= foo 42)\n</code></pre></p> <p>Logical Operations: <pre><code>(or foo default)\n(and x y)\n(not isValid)\n</code></pre></p> <p>All binary operations use prefix notation, where the operator comes first, followed by the operands.</p>"},{"location":"specification/#4-variable-declaration","title":"4. Variable Declaration","text":"<p>Expression: <pre><code>(var &lt;name&gt; &lt;value&gt;)\n</code></pre></p> <p>Examples: <pre><code>(var foo 42)\n(var bar (* foo 10))\n</code></pre></p> <p>The <code>var</code> keyword declares a new variable in the current environment. The variable name is bound to the evaluated value. Variables can be initialized with any expression, including computed values.</p>"},{"location":"specification/#5-assignment-expressions","title":"5. Assignment Expressions","text":"<p>Expression: <pre><code>(set &lt;name&gt; &lt;value&gt;)\n</code></pre></p> <p>Examples: <pre><code>(set foo 42)\n(set bar (* foo 10))\n</code></pre></p> <p>The <code>set</code> keyword updates the value of an existing variable. Unlike <code>var</code>, <code>set</code> does not create new variables - it modifies variables that already exist in the current or parent scopes.</p>"},{"location":"specification/#6-variable-access","title":"6. Variable Access","text":"<p>Expression: <pre><code>&lt;name&gt;\n</code></pre></p> <p>Examples: <pre><code>foo\n(square 2)\n</code></pre></p> <p>Variables are accessed by their name. The interpreter performs identifier resolution by looking up the variable in the current environment. If not found in the current scope, it searches parent scopes recursively.</p>"},{"location":"specification/#7-block-expressions","title":"7. Block Expressions","text":"<p>Expression: <pre><code>(begin &lt;sequence&gt;)\n</code></pre></p> <p>Example: <pre><code>(begin\n  (var foo 42)\n  (set bar (* foo 10))\n  (+ foo bar))\n</code></pre></p> <p>Block expressions group multiple expressions together using the <code>begin</code> keyword. Each expression in the block is evaluated sequentially in a new nested environment. The block returns the value of the last expression. Variables declared within a block are scoped to that block.</p>"},{"location":"specification/#8-branching","title":"8. Branching","text":""},{"location":"specification/#81-if-expressions","title":"8.1. If Expressions","text":"<p>Expression: <pre><code>(if &lt;condition&gt;\n    &lt;consequent&gt;\n    &lt;alternate&gt;)\n</code></pre></p> <p>Example: <pre><code>(if (&gt; x 0)\n    (set y 10)\n    (begin\n      (set y 20)\n      (print \"exit\")))\n</code></pre></p> <p>The <code>if</code> expression evaluates the condition. If the condition is truthy, the consequent expression is evaluated and returned. Otherwise, the alternate expression is evaluated and returned. Both branches can be any expression, including blocks.</p>"},{"location":"specification/#82-switch-expressions","title":"8.2. Switch Expressions","text":"<p>Expression: <pre><code>(switch (&lt;cond1&gt; &lt;block1&gt;)\n        ...\n        (&lt;condN&gt; &lt;blockN&gt;)\n        (else &lt;alternate&gt;))\n</code></pre></p> <p>Example: <pre><code>(switch ((&gt; x 1) 100)\n        ((= x 1) 200)\n        (else 0))\n</code></pre></p> <p>Transformation:</p> <p>The <code>switch</code> expression is syntactic sugar that transforms into nested <code>if</code> expressions:</p> <pre><code>(if &lt;cond1&gt;\n    &lt;block1&gt;\n    ...\n    (if &lt;condN&gt;\n        &lt;blockN&gt;\n        &lt;alternate&gt;))\n</code></pre> <p>Switch provides a cleaner syntax for multi-way branching compared to nested if expressions.</p>"},{"location":"specification/#9-loops","title":"9. Loops","text":""},{"location":"specification/#91-while-loops","title":"9.1. While Loops","text":"<p>Expression: <pre><code>(while &lt;condition&gt;\n       &lt;block&gt;)\n</code></pre></p> <p>Example: <pre><code>(while (&gt; x 10)\n  (begin\n    (-- x)\n    (print x)))\n</code></pre></p> <p>While loops repeatedly evaluate the body block as long as the condition remains truthy. The loop returns the value of the last iteration of the body.</p>"},{"location":"specification/#92-for-loops","title":"9.2. For Loops","text":"<p>Expression: <pre><code>(for &lt;init&gt;\n     &lt;condition&gt;\n     &lt;modifier&gt;\n     &lt;exp&gt;)\n</code></pre></p> <p>Example: <pre><code>(for (var x 10)\n     (&gt; x 0)\n     (-- x)\n     (print x))\n</code></pre></p> <p>Transformation:</p> <p>The <code>for</code> loop is syntactic sugar that transforms into:</p> <pre><code>(begin\n  &lt;init&gt;\n  (while &lt;condition&gt;\n    (begin\n      &lt;exp&gt;\n      &lt;modifier&gt;)))\n</code></pre> <p>For loops provide a convenient way to express iteration with initialization, condition checking, and modification in a single construct.</p>"},{"location":"specification/#10-functions","title":"10. Functions","text":""},{"location":"specification/#101-lambda-expressions","title":"10.1. Lambda Expressions","text":"<p>Expression: <pre><code>(lambda &lt;args&gt;\n        &lt;body&gt;)\n</code></pre></p> <p>Example: <pre><code>(lambda (x) (* x x))\n</code></pre></p> <p>Lambda expressions create anonymous functions with lexical closures. Lambdas are first-class values that can be assigned to variables, passed as arguments, and returned from functions.</p>"},{"location":"specification/#102-function-declarations","title":"10.2. Function Declarations","text":"<p>Expression: <pre><code>(def &lt;name&gt; &lt;args&gt;\n     &lt;body&gt;)\n</code></pre></p> <p>Example: <pre><code>(def square (x)\n  (* x x))\n</code></pre></p> <p>Transformation:</p> <p>Function declarations are syntactic sugar that transforms into a variable declaration with a lambda:</p> <pre><code>(var &lt;name&gt;\n  (lambda &lt;args&gt;\n          &lt;body&gt;))\n</code></pre> <p>This transformation shows that named functions are simply variables bound to lambda expressions.</p>"},{"location":"specification/#103-function-calls","title":"10.3. Function Calls","text":"<p>Expression: <pre><code>(&lt;fn&gt; &lt;args&gt;)\n</code></pre></p> <p>Examples: <pre><code>(square 2)\n((lambda (x) (* x x)) 2)\n</code></pre></p> <p>Function calls evaluate the function expression and all argument expressions, then apply the function to the arguments. AxLang supports both built-in native functions and user-defined functions.</p>"},{"location":"specification/#11-classes","title":"11. Classes","text":"<p>Expression (class definition): <pre><code>(class &lt;name&gt; &lt;parent&gt;\n       &lt;body&gt;)\n</code></pre></p> <p>Expression (instantiation): <pre><code>(new &lt;class&gt; &lt;args&gt;)\n</code></pre></p> <p>Example: <pre><code>(class Point null\n  (begin\n    (def constructor (self x y)\n      ((prop self setX) x)\n      ((prop self setY) y))\n\n    (def getX (self)\n      (prop self x))\n\n    (def setX (self x)\n      (set (prop self x) x))\n\n    (var p (new Point 10 20))\n    ((prop p getX))\n</code></pre></p> <p>Classes provide object-oriented programming capabilities:</p> <ul> <li>Inheritance: Classes can inherit from a parent class (use <code>null</code> for no parent)</li> <li>Constructor: Special <code>constructor</code> method initializes instances</li> <li>Methods: Functions that operate on instance data</li> <li>Properties: Instance variables accessed via <code>prop</code></li> <li>Instantiation: <code>new</code> keyword creates class instances</li> </ul>"},{"location":"specification/#12-modules","title":"12. Modules","text":"<p>Expression (module definition): <pre><code>(module &lt;name&gt;\n        &lt;body&gt;)\n</code></pre></p> <p>Expression (import): <pre><code>(import &lt;name&gt;)\n</code></pre></p> <p>Example: <pre><code>(module Math\n  (begin\n    (def square (x)\n      (* x x))\n\n    (var MAX_VALUE 100)))\n\n(import Math)\n((prop Math square) 2)\n</code></pre></p> <p>Modules provide code organization and namespace management:</p> <ul> <li>Module definition: The <code>module</code> keyword creates a named namespace</li> <li>Encapsulation: Variables and functions defined within a module are scoped to that module</li> <li>Import: The <code>import</code> keyword makes a module available in the current scope</li> <li>Access: Module members are accessed using the <code>prop</code> function</li> </ul> <p>Modules help organize code into logical units and prevent naming conflicts.</p>"},{"location":"specification/#additional-resources","title":"Additional Resources","text":"<ul> <li>API Documentation</li> <li>Getting Started Guide</li> <li>GitHub Repository</li> </ul>"}]}